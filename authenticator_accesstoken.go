package main

import (
	"net/http"

	oidc "github.com/coreos/go-oidc"
	"k8s.io/apiserver/pkg/authentication/authenticator"
	"k8s.io/apiserver/pkg/authentication/user"
)

type accessTokenAuthenticator struct {
	header		string		// header name where access token is stored
	caBundle	[]byte
	provider	*oidc.Provider
	clientID	string		// need client id to verify the id access token
	idTypClaim  string	    // value 'app' if access token generated by app and 'user' for user account
	azpClaim    string      // holds identifier for the App
}

func (s *accessTokenAuthenticator) AuthenticateRequest(r *http.Request) (*authenticator.Response, bool, error) {
	logger := loggerForRequest(r)
	
	// get access-token from header
	bearer := getBearerToken(r.Header.Get(s.header))
	if len(bearer) == 0 {
		return nil, false, nil
	}

	ctx := setTLSContext(r.Context(), s.caBundle)

	// Verifying received Access token
	verifier := s.provider.Verifier(&oidc.Config{ClientID: s.clientID})
	token, err := verifier.Verify(ctx, bearer)
	if err != nil {
		logger.Errorf("access-token verification failed: %v", err)
		return nil, false, nil
	}
	
	// no error check here, because of the Verify() above
	var claims map[string]interface{}
	token.Claims(&claims)
			 
	if claims[s.idTypClaim] != "app" {
		logger.Error("Only Access Token generated from apps are supported")
		return nil, false, nil
	}
 
	// add app indentity for upstream header as for jwt without email claim
	resp := &authenticator.Response{
		User: &user.DefaultInfo{
			Name: claims[s.azpClaim].(string),
		},
	}
	return resp, true, nil
}
